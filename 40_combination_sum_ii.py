class Solution(object):    def combinationSum2(self, candidates, target):        """        :type candidates: List[int]        :type target: int        :rtype: List[List[int]]        """        """        if sum(candidates) < target:            return []        elif len(candidates) == 1 and candidates[0] != target:            return []        elif len(list(set(candidates))) == 1 and sum(candidates) >= target:            return [[candidates[0]] * (target // candidates[0])]        """        def backtrack(start, target, path):            if target == 0:                result.add(tuple(path))  # Store as a tuple to avoid duplicates                return            if target < 0:                return                        for i in range(start, len(candidates)):                # Skip duplicates                if i > start and candidates[i] == candidates[i - 1]:                    continue                # Include candidates[i] and move forward                backtrack(i + 1, target - candidates[i], path + [candidates[i]])                # Sort candidates to help with pruning and skipping duplicates        candidates.sort()        result = set()        backtrack(0, target, [])        return [list(comb) for comb in result]  # Convert result back to list